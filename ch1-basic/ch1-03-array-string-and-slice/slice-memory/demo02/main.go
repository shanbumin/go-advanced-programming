package main

import (
	"io/ioutil"
	"regexp"
)

//避免切片内存泄漏
//如前面所说，切片操作并不会复制底层的数据。
//底层的数组会被保存在内存中，直到它不再被引用。
//但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收。



//例如，`FindPhoneNumber`函数加载整个文件到内存，然后搜索第一个出现的电话号码，最后结果以切片方式返回。
func FindPhoneNumber(filename string) []byte {
  b, _ := ioutil.ReadFile(filename)
  return regexp.MustCompile("[0-9]+").Find(b)
}

//todo 这段代码返回的`[]byte`指向保存整个文件的数组。因为切片引用了整个原始数组，导致自动垃圾回收器不能及时释放底层数组的空间。
//一个小的需求可能导致需要长时间保存整个文件数据。这虽然这并不是传统意义上的内存泄漏，但是可能会拖慢系统的整体性能。

//todo 要修复这个问题，可以将感兴趣的数据复制到一个新的切片中（数据的传值是Go语言编程的一个哲学，虽然传值有一定的代价，但是换取的好处是切断了对原始数据的依赖）：
func FindPhoneNumber2(filename string) []byte {
  b, _ := ioutil.ReadFile(filename)
  b = regexp.MustCompile("[0-9]+").Find(b)
  return append([]byte{}, b...)
}

func main() {


	

  //类似的问题，在删除切片元素时可能会遇到。
  //假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而导致不能及时被自动垃圾回收器回收（这要依赖回收器的实现方式）：

	//var a []*int{ ... }
	//a = a[:len(a)-1]    // 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍


  //todo  总之上述删除的最后一个元素还在内存中，单独去释放某个数组中的元素是要动点脑袋瓜子的
  //保险的方式是先将需要自动内存回收的元素设置为`nil`，保证自动回收器可以发现需要回收的对象，然后再进行切片的删除操作：

	//var a []*int{ ... }
	//a[len(a)-1] = nil // GC回收最后一个元素内存
	//a = a[:len(a)-1]  // 从切片删除最后一个元素

    //当然，如果切片存在的周期很短的话，可以不用刻意处理这个问题。
	//因为如果切片本身已经可以被GC回收的话，切片对应的每个元素自然也就是可以被回收的了。


	
}
