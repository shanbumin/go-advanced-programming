package main

import "fmt"

//根据Go语言规范，Go语言的源文件都是采用UTF8编码。
//因此，Go源文件中出现的字符串面值常量一般也是UTF8编码的（对于转义字符，则没有这个限制）。
//提到Go字符串时，我们一般都会假设字符串对应的是一个合法的UTF8编码的字符序列。
//可以用内置的`print`调试函数或`fmt.Print`函数直接打印，也可以用`for range`循环直接遍历UTF8解码后的Unicode码点值。
//@link http://www.mytju.com/classcode/tools/encode_utf8.asp
func main() {
	fmt.Printf("%#v\n", []byte("Hello, 世界"))  //7+2*3=13个字节
	//1.打印的是UTF8编码后的值,16进制: []byte{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0xe4, 0xb8, 0x96, 0xe7, 0x95, 0x8c}
	fmt.Println("-----------------------------------")

	//2.我们也可以在字符串面值中直指定UTF8编码后的值（源文件中全部是ASCII码，可以避免出现多字节的字符）。

	fmt.Println("\xe4\xb8\x96") // 打印: 世  ===> todo Unicode字符[世]通过UTF-8编码后的值为[E4B896](16进制)
	fmt.Println("\xe7\x95\x8c") // 打印: 界
	fmt.Println("-----------------------------------")

	//3.Go语言的字符串中可以存放任意的二进制字节序列，而且即使是UTF8字符序列也可能会遇到坏的编码。
	//如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符‘\uFFFD’，这个字符在不同的软件中的显示效果可能不太一样，
	//在印刷中这个符号通常是一个黑色六角形或钻石形状，里面包含一个白色的问号‘�’。
	//下面的字符串中，我们故意损坏了第一字符的第二和第三字节，因此第一字符将会打印为“�”，第二和第三字节则被忽略，
	//后面的“界abc”依然可以正常解码打印（错误编码不会向后扩散是UTF8编码的优秀特性之一）。
	fmt.Println("\xe4\x00\x00\xe7\x95\x8cabc") // �界abc
	fmt.Println("-----------------------------------")

	//3.不过在`for range`迭代这个含有损坏的UTF8字符串时，第一字符的第二和第三字节依然会被单独迭代到，不过此时迭代的值是损坏后的0：
	for i, c := range "\xe4\x00\x00\xe7\x95\x8cabc" { //这里直接迭代utf-8字符串
		fmt.Println(i, c)
	}
	// 0 65533  // \uFFFD, 对应 �
	// 1 0      // 空字符
	// 2 0      // 空字符
	// 3 30028  // 界  (Unicode编码10进制)
	// 6 97     // a
	// 7 98     // b
	// 8 99     // c
	fmt.Println("-----------------------------------")
	//4.如果不想解码UTF8字符串，想直接遍历原始的字节码，可以将字符串强制转为`[]byte`字节序列后再行遍历（这里的转换一般不会产生运行时开销）：
	for i, c := range []byte("世界abc") {
		fmt.Println(i, c)
	}
	fmt.Println("-----------------------------------")
	//5.或者是采用传统的下标方式遍历字符串的字节数组：
	const s = "\xe4\xb8\x96\xe7\x95\x8cabc"
	for i := 0; i < len(s); i++ {
		fmt.Printf("%d %x\n", i, s[i]) //utf-8编码16进制
	}

}
