package main

import "fmt"

//添加切片元素
func main() {
	//1.内置的泛型函数`append`可以在切片的尾部追加`N`个元素：
	var a []int
	a = append(a, 1)               // 追加1个元素
	a = append(a, 1, 2, 3)         // 追加多个元素, 手写解包方式
	a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包

	fmt.Printf("%#v\r\n",a)
	fmt.Println("-----------------")

  //不过要注意的是，在容量不足的情况下，`append`的操作会导致重新分配内存，可能导致巨大的内存分配和复制数据代价。
  //即使容量足够，依然需要用`append`函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。

  //2.除了在切片的尾部追加，我们还可以在切片的开头添加元素：
   var a2= []int{1,2,3}
   a2 = append([]int{0}, a...)        // 在开头添加1个元素
   a2 = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片
   fmt.Printf("%#v\r\n",a2)
	fmt.Println("-----------------")
   //在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制1次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。
   //3.由于`append`函数返回新的切片，也就是它支持链式操作。我们可以将多个`append`操作组合起来，实现在切片中间插入元素：

	var a3 []int
    var i=0
    var x=5
	a3 = append(a3[:i], append([]int{x}, a3[i:]...)...)     // 在第i个位置插入x
	fmt.Printf("%#v\r\n",a3)
	a3 = append(a3[:i], append([]int{1,2,3}, a3[i:]...)...) // 在第i个位置插入切片
	fmt.Printf("%#v\r\n",a3)
	fmt.Println("-----------------")

  //每个添加操作中的第二个`append`调用都会创建一个临时切片，并将`a[i:]`的内容复制到新创建的切片中，然后将临时创建的切片再追加到`a[:i]`。
  //4.可以用`copy`和`append`组合可以避免创建中间的临时切片，同样是完成添加元素的操作：

	    var a4 =[]int{1,2,3,4,5}
	    i=2
	    x=9
	    a4 = append(a4, 0)     // 切片扩展1个空间
		copy(a4[i+1:], a4[i:]) // a4[i:]向后移动1个位置 todo 这种移动方法真的弱鸡，整体将i下标之后的元素，复制到i+1位置开始往后顺延
		a4[i] = x             // 设置新添加的元素

	fmt.Printf("%#v\r\n",a4)
	fmt.Println("-----------------")

    //第一句`append`用于扩展切片的长度，为要插入的元素留出空间。
    //第二句`copy`操作将要插入位置开始之后的元素向后挪动一个位置。
    //第三句真实地将新添加的元素赋值到对应的位置。
    //操作语句虽然冗长了一点，但是相比前面的方法，可以减少中间创建的临时切片。


   //5.用`copy`和`append`组合也可以实现在中间位置插入多个元素(也就是插入一个切片):

	//a = append(a, x...)       // 为x切片扩展足够的空间
	//copy(a[i+len(x):], a[i:]) // a[i:]向后移动len(x)个位置
	//copy(a[i:], x)            // 复制新添加的切片

    //稍显不足的是，在第一句扩展切片容量的时候，扩展空间部分的元素复制是没有必要的。
    //没有专门的内置函数用于扩展切片的容量，`append`本质是用于追加元素而不是扩展容量，扩展切片容量只是`append`的一个副作用。



}
