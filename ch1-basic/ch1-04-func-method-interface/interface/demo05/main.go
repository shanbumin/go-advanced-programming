package main



//有时候对象和接口之间太灵活了，导致我们需要人为地限制这种无意之间的适配。
//常见的做法是定义一个含特殊方法来区分接口。

//1.在protobuf中，`Message`接口也采用了类似的方法，也定义了一个特有的`ProtoMessage`，用于避免其它类型无意中适配了该接口：

/*
type proto.Message interface {
   Reset()
   String() string
   ProtoMessage()
}
*/



//2.不过这种做法只是君子协定，如果有人刻意伪造一个`proto.Message`接口也是很容易的。
//再严格一点的做法是给接口定义一个私有方法。
//只有满足了这个私有方法的对象才可能满足这个接口，而私有方法的名字是包含包的绝对路径名的，因此只能在包内部实现这个私有方法才能满足这个接口。
//测试包中的`testing.TB`接口就是采用类似的技术：
//略

//不过这种通过私有方法禁止外部对象实现接口的做法也是有代价的：
//首先是这个接口只能包内部使用，外部包正常情况下是无法直接创建满足该接口对象的；

//其次，这种防护措施也不是绝对的，恶意的用户依然可以绕过这种保护机制。比如通过继承:
//通过在结构体中嵌入匿名类型成员，可以继承匿名类型的方法。
//其实这个被嵌入的匿名成员不一定是普通类型，也可以是接口类型。
//我们可以通过嵌入匿名的`testing.TB`接口来伪造私有的`private`方法，因为【接口方法是延迟绑定】，编译时`private`方法是否真的存在并不重要。

//这种通过嵌入匿名接口或嵌入匿名指针对象来实现继承的做法其实是一种【纯虚继承】，我们继承的只是接口指定的规范，真正的实现在运行的时候才被注入。

//todo Go语言通过几种简单特性的组合，就轻易就实现了鸭子面向对象和虚拟继承等高级特性，真的是不可思议。

func main() {

	
}
