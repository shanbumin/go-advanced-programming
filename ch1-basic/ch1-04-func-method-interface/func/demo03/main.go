package main

//todo  闭包

//1.如果返回值命名了，可以通过名字来修改返回值，也可以通过`defer`语句在`return`语句之后修改返回值：
func Inc() (v int) {
	//todo 其中`defer`语句延迟执行了一个匿名函数，因为这个匿名函数捕获了外部函数的局部变量`v`，这种函数我们一般叫闭包。
	//闭包对捕获的外部变量并不是传值方式访问，而是以引用的方式访问。
	defer func(){ v++ } ()
	return 42
}


func main() {
	//1.闭包的这种引用方式访问外部变量的行为可能会导致一些隐含的问题：
	//因为是闭包，在`for`迭代语句中，每个`defer`语句延迟执行的函数引用的都是同一个`i`迭代变量，在循环结束后这个变量的值为3，因此最终输出的都是3。
	for i := 0; i < 3; i++ {
		defer func(){ println(i) } ()
	}
	//2.修复的思路是在每轮迭代中为每个`defer`函数生成独有的变量。可以用下面两种方式：
	//第一种方法是在循环体内部再定义一个局部变量，这样每次迭代`defer`语句的闭包函数捕获的都是不同的变量，这些变量的值对应迭代时的值。
	for i := 0; i < 3; i++ {
		i := i // 定义一个循环体内局部变量i
		defer func(){ println(i) } ()
	}
	//第二种方式是将迭代变量通过闭包函数的参数传入，`defer`语句会马上对调用参数求值。
	//两种方式都是可以工作的。不过一般来说,在`for`循环内部执行`defer`语句并不是一个好的习惯，此处仅为示例，不建议使用。
	for i := 0; i < 3; i++ {
		// 通过函数传入i
		// defer 语句会马上对调用参数求值
		defer func(i int){ println(i) } (i)
	}
	//两种方式都是可以工作的。不过一般来说,在`for`循环内部执行`defer`语句并不是一个好的习惯，此处仅为示例，不建议使用。





}
