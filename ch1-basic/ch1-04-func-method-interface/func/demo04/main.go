package main



//Go语言中，如果以切片为参数调用函数时，有时候会给人一种参数采用了传引用的方式的假象：
//因为在被调用函数内部可以修改传入的切片的元素。
//其实，任何可以通过函数参数修改调用参数的情形，都是因为函数参数中显式或隐式传入了指针参数。
//todo 函数参数传值的规范更准确说是只针对数据结构中固定的部分传值，
//todo 例如字符串或切片对应结构体中的指针和字符串长度结构体传值，但是并不包含指针间接指向的内容。
//todo 将切片类型的参数替换为类似`reflect.SliceHeader`结构体就很好理解切片传值的含义了,本质可以看成就是传递了这个结构体，只是结构体中的某个属性是指针吧了，本质就是值传递啊


//因为切片中的底层数组部分是通过隐式指针传递(指针本身依然是传值的，但是指针指向的却是同一份的数据)，所以被调用函数是可以通过指针修改掉调用参数切片中的数据。
//除了数据之外，切片结构还包含了切片长度和切片容量信息，这2个信息也是传值的。
//如果被调用函数中修改了`Len`或`Cap`信息的话，就无法反映到调用参数的切片中，这时候我们一般会通过返回修改后的切片来更新之前的切片。
//这也是为何内置的`append`必须要返回一个切片的原因。


func twice(x []int) {
	for i := range x {
		x[i] *= 2
	}
}


type IntSliceHeader struct {
	Data []int
	Len  int
	Cap  int
}
//本质是值传递额
func twice2(x IntSliceHeader) {
	for i := 0; i < x.Len; i++ {
		x.Data[i] *= 2
	}
}




func main() {


	
}
